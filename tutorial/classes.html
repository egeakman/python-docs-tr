
<!DOCTYPE html>

<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<meta property="og:title" content="9. Sınıflar" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/tutorial/classes.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Sınıflar, verileri ve işlevleri bir arada tutan bir araçtır. Yeni bir sınıf oluşturulurken, objeye ait yeni örnekler (instances) oluşturulur. Sınıf örnekleri, durumlarını korumak için onlara ilişti..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Sınıflar, verileri ve işlevleri bir arada tutan bir araçtır. Yeni bir sınıf oluşturulurken, objeye ait yeni örnekler (instances) oluşturulur. Sınıf örnekleri, durumlarını korumak için onlara ilişti..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>9. Sınıflar &#8212; Python 3.11.5 belgelendirmesi</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=b37c26da2f7529d09fe70b41c4b2133fe4931a90" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.11.5 belgelendirmesi içinde ara"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Bu belgeler hakkında" href="../about.html" />
    <link rel="index" title="Dizin" href="../genindex.html" />
    <link rel="search" title="Ara" href="../search.html" />
    <link rel="copyright" title="Telif Hakkı" href="../copyright.html" />
    <link rel="next" title="10. Standart Kütüphanenin Özeti" href="stdlib.html" />
    <link rel="prev" title="8. Hatalar ve Özel Durumlar" href="errors.html" />
    <link rel="canonical" href="https://docs.python.org/3/tutorial/classes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="search" name="q" />
                <input type="submit" value="Git"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">İçindekiler</a></h3>
    <ul>
<li><a class="reference internal" href="#">9. Sınıflar</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. İsim ve Nesneler Hakkında Birkaç Şey</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Python Etki Alanları ve Ad Alanları</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. Kapsamlar ve Ad Alanları Örneği</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. Sınıflara İlk Bakış</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Sınıf Tanımlama Söz Dizimi</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Sınıf Nesneleri</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. Örnek Nesneleri</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Metot Nesneleri</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Sınıf ve Örnek Değişkenleri</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. Rastgele Açıklamalar</a></li>
<li><a class="reference internal" href="#inheritance">9.5. Kalıtım</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. Çoklu Kalıtım</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. Özel Değişkenler</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. Oranlar ve Bitişler</a></li>
<li><a class="reference internal" href="#iterators">9.8. Yineleyiciler</a></li>
<li><a class="reference internal" href="#generators">9.9. Üreteçler</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. Üreteç İfadeleri</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Önceki konu</h4>
    <p class="topless"><a href="errors.html"
                          title="önceki bölüm"><span class="section-number">8. </span>Hatalar ve Özel Durumlar</a></p>
  </div>
  <div>
    <h4>Sonraki konu</h4>
    <p class="topless"><a href="stdlib.html"
                          title="sonraki bölüm"><span class="section-number">10. </span>Standart Kütüphanenin Özeti</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Bu Sayfa</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Hata Bildir</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/tutorial/classes.rst"
            rel="nofollow">Kaynağı Göster
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Genel Endeks"
             accesskey="I">dizin</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Modül Dizini"
             >modülleri</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Standart Kütüphanenin Özeti"
             accesskey="N">sonraki</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. Hatalar ve Özel Durumlar"
             accesskey="P">önceki</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python Öğreticisi</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Sınıflar</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="search" name="q" id="search-box" />
          <input type="submit" value="Git" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="classes">
<span id="tut-classes"></span><h1><span class="section-number">9. </span>Sınıflar<a class="headerlink" href="#classes" title="Permalink to this heading">¶</a></h1>
<p>Sınıflar, verileri ve işlevleri bir arada tutan bir araçtır. Yeni bir sınıf oluşturulurken, objeye ait yeni örnekler (instances) oluşturulur. Sınıf örnekleri, durumlarını korumak için onlara iliştirilmiş niteliklere sahip olabilir. Sınıfların durumunu modifiye etmek için ise metotlar kullanılabilir.</p>
<p>Diğer programlama dilleriyle karşılaştırıldığında, Python’un sınıf mekanizması olabildiğince az yeni sözdizimi ve semantik içeren sınıflar ekler.  C++ ve Modula-3’te bulunan sınıf mekanizmalarının bir karışımıdır.  Python sınıfları Nesne Yönelimli Programlama’nın tüm standart özelliklerini sağlar: sınıf devralma mekanizması birden çok temel sınıfa izin verir, türetilmiş bir sınıf temel sınıfının veya sınıflarının herhangi bir metodunu geçersiz kılabilir ve bir metot aynı ada sahip bir temel sınıfın metodunu çağırabilir.  Nesneler farklı miktar ve türlerde veri içerebilir.  Modüller için olduğu gibi, sınıflar da Python’un dinamik doğasına uygundur: çalışma sırasında oluşturulurlar ve oluşturulduktan sonra da değiştirilebilirler.</p>
<p>C++ terminolojisinde, normalde sınıf üyeleri (veri üyeleri dahil) <em>public</em> (aşağıdakine bakın <a class="reference internal" href="#tut-private"><span class="std std-ref">Özel Değişkenler</span></a>) ve tüm üye fonksiyonları <em>virtual</em>’ dır.  Modula-3’te olduğu gibi, nesnenin üyelerine metotlarından ulaşmak için bir kısayol yoktur: metodun işlevi, çağrı tarafından örtülü olarak sağlanan objeyi temsil eden açık bir argümanla bildirilir.  Smalltalk’ta olduğu gibi, sınıfların kendileri de birer nesnedir.  Bu sayede metotlar yeniden isimlendirilebilir veya içe aktarılabilir.  C++ ve Modula-3’ün aksine, yerleşik türler kullanıcının üzerlerine yapacağı geliştirmeler için temel sınıflar olarak kullanılabilir.  Ayrıca, C++’ta olduğu gibi, özel sözdizimine sahip çoğu yerleşik işleç (aritmetik işleçler, alt simgeleme vb.) sınıf örnekleri için yeniden tanımlanabilir, geliştirilebilir.</p>
<p>(Sınıflara dair evrensel terimlerin yanı sıra, nadiren Smalltalk ve C++ terimlerini kullanacağım. Onun yerine Modula-3 terimlerini kullanacağım çünkü Python’un nesne yönelimli semantiğine C++’tan daha yakın, yine de ancak çok az okuyucunun bunları duymuş olacağını tahmin ediyorum.)</p>
<section id="a-word-about-names-and-objects">
<span id="tut-object"></span><h2><span class="section-number">9.1. </span>İsim ve Nesneler Hakkında Birkaç Şey<a class="headerlink" href="#a-word-about-names-and-objects" title="Permalink to this heading">¶</a></h2>
<p>Nesnelerin bireyselliği vardır ve birden çok ad (birden çok kapsamda) aynı nesneye bağlanabilir.  Bu, diğer dillerde örtüşme (aliasing) olarak bilinir.  Bu genellikle Python’a ilk bakışta takdir edilmeyen bir özellik olsa da değiştirilemeyen veri türleriyle (sayılar, dizeler, diziler) uğraşırken rahatlıkla göz ardı edilebilir.  Ancak, örtüşmeler, listeler, sözlükler ve diğer türlerin çoğu gibi değişebilir nesneleri içeren Python kodunun semantiği üzerinde şaşırtıcı bir etkiye sahiptir. Diğer adlar bazı açılardan işaretçiler (pointers) gibi davrandığından, bu genellikle programın yararına kullanılır.  Örneğin, bir nesneyi geçirmek kolaydır çünkü uygulama tarafından geçirilen şey yalnızca bir işaretçidir; bir fonksiyon argüman olarak geçirilen bir nesneyi değiştirirse, çağıran bu değişikliği görür — bu Pascal’daki iki farklı bağımsız değişken geçirme mekanizmasına olan gereksinimi ortadan kaldırır.</p>
</section>
<section id="python-scopes-and-namespaces">
<span id="tut-scopes"></span><h2><span class="section-number">9.2. </span>Python Etki Alanları ve Ad Alanları<a class="headerlink" href="#python-scopes-and-namespaces" title="Permalink to this heading">¶</a></h2>
<p>Sınıflara başlamadan önce, size Python’un etki alanı kuralları hakkında bir şey söylemeliyim.  Sınıf tanımlarında ad alanlarının kullanımının bazı püf noktaları vardır ve neler olduğunu tam olarak anlamak için etki alanlarının ve isimlerin nasıl çalıştığını bilmeniz gerekir. Bu arada, bu konuda bilgi edinmek herhangi bir ileri düzey Python programcısı için yararlıdır.</p>
<p>Haydi birkaç tanımlama ile başlayalım.</p>
<p><em>Ad alanları</em> (namespace), adlardan nesnelere eşlemedir.  Çoğu isim şu anda Python sözlükleri olarak uygulanmaktadır, ancak bu fark edilir çapta bir fark yaratmaz (performans hariç) ve gelecekte değişebilir.  Ad alanlarına örnek olarak şunlar verilebilir: yerleşik isimler (<a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> ve yerleşik özel durum adları gibi fonksiyonları içerir); modüldeki global adlar; ve bir fonksiyon çağırmadaki yerel adlar.  Bir bakıma, bir nesnenin nitelik kümesi de bir ad alanı oluşturur.  İsimler hakkında bilinmesi gereken önemli şey, farklı ad alanlarındaki adlar arasında kesinlikle bir ilişki olmamasıdır; örneğin, iki farklı modülün her ikisi de karışıklık olmadan <code class="docutils literal notranslate"><span class="pre">maximize</span></code> fonksiyonunu tanımlayabilir — modül kullanıcılarının modül adını örneklemesi gerekir.</p>
<p>Bu arada, <em>nitelik</em> sözcüğünü bir noktayı takip eden herhangi bir isim için kullanıyorum. Mesela,  <code class="docutils literal notranslate"><span class="pre">z.real</span></code> ifadesinde <code class="docutils literal notranslate"><span class="pre">real</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> nesnesine ait bir niteliktir. Açıkçası, modüllerde isimlere yapılan referanslar nitelik referanslarıdır: <code class="docutils literal notranslate"><span class="pre">modname.funcname</span></code> ifadesinde <code class="docutils literal notranslate"><span class="pre">modname</span></code> bir modül nesnesi ve <code class="docutils literal notranslate"><span class="pre">funcname</span></code> onun bir niteliğidir. Bu durumda, modülün nitelikleri ve modüldeki global değişkenler arasında bir eşleşme olur: aynı ad alanını paylaşmaları! <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>Attributes may be read-only or writable.  In the latter case, assignment to
attributes is possible.  Module attributes are writable: you can write
<code class="docutils literal notranslate"><span class="pre">modname.the_answer</span> <span class="pre">=</span> <span class="pre">42</span></code>.  Writable attributes may also be deleted with the
<a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> statement.  For example, <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">modname.the_answer</span></code> will remove
the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">the_answer</span></code> from the object named by <code class="docutils literal notranslate"><span class="pre">modname</span></code>.</p>
<p>Ad alanları farklı anlarda oluşturulur ve farklı yaşam sürelerine sahiptir.  Yerleşik adları içeren ad alanı, Python yorumlayıcısı başlatıldığında oluşturulur ve hiçbir zaman silinmez.  Modül tanımı okunduğunda modül için genel ad alanı oluşturulur; normalde, modül ad alanları da yorumlayıcı çıkıp bitene kadar sürer.  Bir komut dosyasından veya etkileşimli olarak okunan yorumlayıcının en üst düzey çağrısı tarafından yürütülen ifadeler <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> adlı bir modülün parçası olarak kabul edilir, bu nedenle kendi genel ad alanlarına sahiptirler.  (Yerleşik isimler aslında bir modülde de yaşar; buna <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>.)</p>
<p>Bir işlevin yerel ad alanı, bir fonksiyon çağrıldığında oluşturulur ve fonksiyon başa çıkamadığı bir hata veya istisna ile karşılaştığında silinir.  (Aslında, bir bakıma ad alanı unutulmaktadır diyebiliriz.)  Tabii ki, özyinelemeli çağrıların her birinin kendi yerel ad alanı vardır.</p>
<p><em>scope</em>, bir ad alanının doğrudan erişilebilir olduğu Python programının metinsel bölgesidir.  Burada “Doğrudan erişilebilir”, niteliksiz bir başvurunun hedeflediği ismi ad alanında bulmaya çalıştığı anlamına gelir.</p>
<p>Kapsamlar statik olarak belirlense de, dinamik olarak kullanılırlar. Yürütme sırasında herhangi bir zamanda, ad alanlarına doğrudan erişilebilen 3 veya 4 iç içe kapsam vardır:</p>
<ul class="simple">
<li><p>en içte bulunan kapsam, ilk aranan olmakla birlikte yerel isimleri içerir</p></li>
<li><p>en yakın kapsayan kapsamdan başlayarak aranan kapsayan fonksiyonların kapsamları yerel olmayan, aynı zamanda genel olmayan adlar içerir</p></li>
<li><p>sondan bir önceki kapsam, geçerli modülün genel adlarını içerir</p></li>
<li><p>en dıştaki kapsam (en son aranan), yerleşik adlar içeren ad alanıdır</p></li>
</ul>
<p>Bir ad global olarak bildirilirse, tüm başvurular ve atamalar doğrudan modülün genel adlarını içeren orta kapsama gider.  En iç kapsamın dışında bulunan değişkenleri yeniden bağlamak için <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> ifadesi kullanılabilir; yerel olarak bildirilmezse de, bu değişkenler salt okunurdur (böyle bir değişken düzenlenirse, aynı adlı dış değişkeni değiştirmeden en iç kapsamda <em>yeni</em> bir yerel değişken oluşturur).</p>
<p>Genellikle, yerel kapsam (metinsel olarak) geçerli fonksiyonun yerel adlarına başvurur.  Dış fonksiyonlarda, yerel kapsam genel kapsamla aynı ad alanına başvurur: modülün ad alanı. Sınıf tanımları yerel kapsamda başka bir ad alanı yerleştirir.</p>
<p>Kapsamların metinsel olarak belirlendiğini fark etmek önemlidir: bir modülde tanımlanan bir işlevin genel kapsamı, işlevin nereden veya hangi diğer adla adlandırıldığından bağımsız olarak modülün ad alanıdır.  Öte yandan, gerçek ad araması dinamik olarak yapılır, çalışma zamanında — ancak, dil tanımı statik ad çözümlemelerine doğru, “derleme” zamanında gelişir, bu nedenle dinamik ad çözümlemesini güvenmeyin!  (Aslında, yerel değişkenler zaten statik olarak belirlenir.)</p>
<p>Python’un özel bir cilvesi, eğer <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> veya <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> deyimi geçerli değilse – isimlere yapılan atamaların her zaman en içteki kapsama girmesidir. Atamalar verileri kopyalamaz — adları nesnelere bağlarlar.  Aynı şey silme için de geçerlidir: <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> deyimi, <code class="docutils literal notranslate"><span class="pre">x</span></code> bağlamasını yerel kapsam tarafından başvurulan ad alanından kaldırır.  Aslında, yeni adlar tanıtan tüm işlemler yerel kapsamı kullanır: özellikle, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> ifadeleri ve işlev tanımları modül veya işlev adını yerel kapsamda bağlar.</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> deyimi, belirli değişkenlerin genel kapsamda yaşadığını ve orada geri alınması gerektiğini belirtmek için kullanılabilir; <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> deyimi, belirli değişkenlerin bir çevreleme kapsamında yaşadığını ve orada geri alınması gerektiğini gösterir.</p>
<section id="scopes-and-namespaces-example">
<span id="tut-scopeexample"></span><h3><span class="section-number">9.2.1. </span>Kapsamlar ve Ad Alanları Örneği<a class="headerlink" href="#scopes-and-namespaces-example" title="Permalink to this heading">¶</a></h3>
<p>Bu, farklı kapsamlara ve ad alanlarına başvurmayı ve <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> ve <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> değişken bağlamasını nasıl etkileyeceğini gösteren bir örnektir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scope_test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">do_local</span><span class="p">():</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;local spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_nonlocal</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;nonlocal spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_global</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;global spam&quot;</span>

    <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;test spam&quot;</span>
    <span class="n">do_local</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After local assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_nonlocal</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After nonlocal assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_global</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After global assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>

<span class="n">scope_test</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In global scope:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
</pre></div>
</div>
<p>Örnek kodun çıktısı şudur:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</pre></div>
</div>
<p>Varsayılan atama olan <em>local</em> atamasının <em>scope_test</em>'in <em>spam</em> bağlamasını nasıl değiştirmediğini unutmayın.  <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> ataması <em>scope_test</em>'in <em>spam</em> bağlamasını değiştirdi, hatta <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> ataması modül düzeyindeki bağlamasını değiştirdi.</p>
<p>Ayrıca <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> atamasından önce <em>spam</em> için herhangi bir bağlama olmadığını görebilirsiniz.</p>
</section>
</section>
<section id="a-first-look-at-classes">
<span id="tut-firstclasses"></span><h2><span class="section-number">9.3. </span>Sınıflara İlk Bakış<a class="headerlink" href="#a-first-look-at-classes" title="Permalink to this heading">¶</a></h2>
<p>Sınıflar biraz yeni söz dizimi, üç yeni nesne türü ve bazı yeni semantiklere sahiptir.</p>
<section id="class-definition-syntax">
<span id="tut-classdefinition"></span><h3><span class="section-number">9.3.1. </span>Sınıf Tanımlama Söz Dizimi<a class="headerlink" href="#class-definition-syntax" title="Permalink to this heading">¶</a></h3>
<p>Sınıf tanımlamasının en basit biçimi şöyledir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassName</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Sınıf tanımlamaları, fonksiyon tanımlamaları (<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> deyimleri) ile aynı şekilde, herhangi bir etkiye sahip olmadan önce yürütülmelidir.  (Bir sınıf tanımını <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> ifadesinin bir dalına veya bir fonksiyonun içine yerleştirebilirsiniz.)</p>
<p>Uygulamada, bir sınıf tanımı içindeki ifadeler genellikle fonksiyon tanımlamaları olacaktır, ancak diğer ifadelere de izin verilir ve daha sonra bahsedeceğimiz üzere bazen yararlılardır. Bir sınıfın içindeki fonksiyon tanımları normalde, yöntemler için çağırma kuralları tarafından dikte edilen tuhaf bir bağımsız değişken listesi biçimine sahiptir — bu daha sonra açıklanacak.</p>
<p>Sınıf tanımı girildiğinde, yeni bir ad alanı oluşturulur ve yerel kapsam olarak kullanılır — böylece yerel değişkenlere yapılan tüm atamalar bu yeni ad alanına gider.  Özellikle, fonksiyon tanımlamaları yeni fonksiyonların adını buraya bağlar.</p>
<p>When a class definition is left normally (via the end), a <em>class object</em> is
created.  This is basically a wrapper around the contents of the namespace
created by the class definition; we’ll learn more about class objects in the
next section.  The original local scope (the one in effect just before the class
definition was entered) is reinstated, and the class object is bound here to the
class name given in the class definition header (<code class="xref py py-class docutils literal notranslate"><span class="pre">ClassName</span></code> in the
example).</p>
</section>
<section id="class-objects">
<span id="tut-classobjects"></span><h3><span class="section-number">9.3.2. </span>Sınıf Nesneleri<a class="headerlink" href="#class-objects" title="Permalink to this heading">¶</a></h3>
<p>Sınıf nesneleri iki tür işlemi destekler: nitelik referansları ve örnekleme.</p>
<p><em>Nitelik referansları</em>, Python’daki tüm nitelik referansları için kullanılan standart söz dizimi olan <code class="docutils literal notranslate"><span class="pre">obj.name</span></code> kullanır.  Geçerli nitelik adları, sınıf nesnesi oluşturulduğunda sınıfın ad alanında bulunan tüm adlardır.  Yani, sınıf tanımı şöyle görünüyorsa:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>
</div>
<p>then <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> and <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> are valid attribute references, returning
an integer and a function object, respectively. Class attributes can also be
assigned to, so you can change the value of <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> by assignment.
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> is also a valid attribute, returning the docstring belonging to
the class: <code class="docutils literal notranslate"><span class="pre">&quot;A</span> <span class="pre">simple</span> <span class="pre">example</span> <span class="pre">class&quot;</span></code>.</p>
<p>Sınıf <em>örnekleme</em> fonksiyon notasyonunu kullanır.  Sınıf nesnesinin, sınıfın yeni bir örneğini döndüren parametresiz bir fonksiyon olduğunu varsayın. Örneğin (yukarıdaki sınıfı varsayarsak):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>sınıfın yeni bir <em>örnek</em> öğesini oluşturur ve bu nesneyi <code class="docutils literal notranslate"><span class="pre">x</span></code> yerel değişkenine atar.</p>
<p>The instantiation operation (“calling” a class object) creates an empty object.
Many classes like to create objects with instances customized to a specific
initial state. Therefore a class may define a special method named
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>When a class defines an <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method, class instantiation
automatically invokes <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> for the newly created class instance.  So
in this example, a new, initialized instance can be obtained by:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>Of course, the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method may have arguments for greater
flexibility.  In that case, arguments given to the class instantiation operator
are passed on to <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>.  For example,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</section>
<section id="instance-objects">
<span id="tut-instanceobjects"></span><h3><span class="section-number">9.3.3. </span>Örnek Nesneleri<a class="headerlink" href="#instance-objects" title="Permalink to this heading">¶</a></h3>
<p>Şimdi örnek nesnelerle ne yapabiliriz?  Örnek nesneleri tarafından anlaşılan tek işlemler nitelik başvurularıdır.  İki tür geçerli öznitelik adı vardır: veri nitelikleri ve metotları.</p>
<p><em>data attributes</em> correspond to “instance variables” in Smalltalk, and to “data
members” in C++.  Data attributes need not be declared; like local variables,
they spring into existence when they are first assigned to.  For example, if
<code class="docutils literal notranslate"><span class="pre">x</span></code> is the instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> created above, the following piece of
code will print the value <code class="docutils literal notranslate"><span class="pre">16</span></code>, without leaving a trace:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</div>
<p>Diğer örnek nitelik başvurusu türü bir <em>metot</em>. Metot, bir nesneye “ait” olan bir fonksiyondur.  (Python’da, terim metodu sınıf örneklerine özgü değildir: diğer nesne türlerinin de metotları olabilir.  Örneğin, liste nesnelerini genişletme, ekleme, kaldırma, sıralama vb. Ancak, aşağıdaki tartışmada, aksi açıkça belirtilmedikçe, yalnızca sınıf örneği nesnelerinin metotlarını ifade etmek için terim metodunu kullanacağız.)</p>
<p id="index-0">Örnek nesnesinin geçerli metot adları nesnenin sınıfına bağlıdır.  Fonksiyon nesneleri olan bir sınıfın tüm nitelikleri, örneklerinin karşılık gelen fonksiyonlarını tanımlar.  Bu nedenle, örneğimizde, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> geçerli bir metot referansıdır, ne de olsa <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> bir fonksiyondur ancak <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> fonksiyon olmadığından <code class="docutils literal notranslate"><span class="pre">x.i</span></code> değildir.  Ancak <code class="docutils literal notranslate"><span class="pre">x.f</span></code>, <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> ile aynı şey değildir çünkü bir fonksiyon nesnesi değil, <em>metot nesnesi</em> ‘dir.</p>
</section>
<section id="method-objects">
<span id="tut-methodobjects"></span><h3><span class="section-number">9.3.4. </span>Metot Nesneleri<a class="headerlink" href="#method-objects" title="Permalink to this heading">¶</a></h3>
<p>Genellikle, bir metot bağlandıktan hemen sonra çağrılır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>In the <code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> example, this will return the string <code class="docutils literal notranslate"><span class="pre">'hello</span> <span class="pre">world'</span></code>.
However, it is not necessary to call a method right away: <code class="docutils literal notranslate"><span class="pre">x.f</span></code> is a method
object, and can be stored away and called at a later time.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">xf</span><span class="p">())</span>
</pre></div>
</div>
<p>daima <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> yazdırmaya devam edecek.</p>
<p>What exactly happens when a method is called?  You may have noticed that
<code class="docutils literal notranslate"><span class="pre">x.f()</span></code> was called without an argument above, even though the function
definition for <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> specified an argument.  What happened to the argument?
Surely Python raises an exception when a function that requires an argument is
called without any — even if the argument isn’t actually used…</p>
<p>Aslında, cevabı tahmin etmiş olabilirsiniz: yöntemlerle ilgili özel şey, örnek nesnesinin fonksiyonun ilk argüman olarak geçirilmesidir.  Örneğimizde, <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> çağrısı tam olarak <code class="docutils literal notranslate"><span class="pre">MyClass.f(x)</span></code> ile eş değerdir.  Genel olarak, <em>n</em> tane argümana sahip bir metodu çağırmak, ilk argümandan önce metodun örnek nesnesi eklenerek oluşturulan bir argüman listesiyle karşılık gelen fonksiyonu çağırmaya eş değerdir.</p>
<p>Metotların nasıl çalıştığını hala anlamıyorsanız, nasıl uygulandığına bakmak belki de sorunları açıklığa kavuşturabilir.  Bir örneğin, veri olmayan bir niteliğine başvurulduğu zaman bu örneğin ait olduğu sınıfa bakılır.  Ad bir fonksiyon nesnesi olan geçerli bir sınıf özniteliğini gösterirse, örnek nesne ve fonksiyon nesnesi soyut bir nesnede paketlenerek (işaretçiler) bir metot nesnesi oluşturulur. İşte bu metot nesnesidir.  Metot nesnesi bir argüman listesiyle çağrıldığında, örnek nesneden ve argüman listesinden yeni bir argüman listesi oluşturulur ve fonksiyon nesnesi bu yeni argüman listesiyle çağrılır.</p>
</section>
<section id="class-and-instance-variables">
<span id="tut-class-and-instance-variables"></span><h3><span class="section-number">9.3.5. </span>Sınıf ve Örnek Değişkenleri<a class="headerlink" href="#class-and-instance-variables" title="Permalink to this heading">¶</a></h3>
<p>Genel olarak, örnek değişkenleri o örneğe özgü veriler içindir ve sınıf değişkenleri sınıfın tüm örnekleri tarafından paylaşılan nitelikler ile metotlar içindir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;canine&#39;</span>         <span class="c1"># class variable shared by all instances</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>    <span class="c1"># instance variable unique to each instance</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to d</span>
<span class="s1">&#39;Fido&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to e</span>
<span class="s1">&#39;Buddy&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#tut-object"><span class="std std-ref">İsim ve Nesneler Hakkında Birkaç Şey</span></a> ‘te anlatıldığı gibi, paylaşılan veriler listeler ve sözlükler gibi <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> nesnelerini içeren şaşırtıcı etkilere sahip olabilir. Örneğin, aşağıdaki koddaki <em>tricks</em> listesi sınıf değişkeni olarak kullanılmamalıdır, çünkü yalnızca tek bir liste tüm <em>Dog</em> örnekleri tarafından paylaşılacaktır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>             <span class="c1"># mistaken use of a class variable</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>                <span class="c1"># unexpectedly shared by all dogs</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">,</span> <span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Doğru olan ise veriyi paylaşmak yerine bir örnek değişkeni kullanmaktır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># creates a new empty list for each dog</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="random-remarks">
<span id="tut-remarks"></span><h2><span class="section-number">9.4. </span>Rastgele Açıklamalar<a class="headerlink" href="#random-remarks" title="Permalink to this heading">¶</a></h2>
<p>Aynı nitelik adı hem bir örnekte hem de bir sınıfta oluşuyorsa, nitelik araması örneğe öncelik verir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Warehouse</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">purpose</span> <span class="o">=</span> <span class="s1">&#39;storage&#39;</span>
<span class="gp">... </span>   <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;west&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w1</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w1</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w1</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage west</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;east&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w2</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w2</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage east</span>
</pre></div>
</div>
<p>Veri niteliklerine metotların yanı sıra bir nesnenin sıradan kullanıcıları (“istemciler”) tarafından başvurulabilir.  Başka bir deyişle, sınıflar saf soyut veri türlerini uygulamak için kullanılamaz.  Aslında, Python’daki hiçbir şey, veri gizlemeyi zorlamaz. Bu durum geleneksel kullanımından dolayı bu şekildedir.  (Öte yandan, C ile yazılan Python uygulamaları, uygulama ayrıntılarını tamamen gizleyebilir ve gerekirse bir nesneye erişimi kontrol edebilir; bu, C ile yazılmış Python uzantıları tarafından kullanılabilir.)</p>
<p>İstemciler veri niteliklerini dikkatle kullanmalıdır — istemciler veri özniteliklerini damgalayarak yöntemler tarafından tutulan değişmezleri bozabilir.  İstemcilerin, metotların geçerliliğini etkilemeden bir örnek nesnesine kendi veri niteliklerini ekleyebileceğini unutmayın. Tabii ki burada da ad çakışmalarından kaçınılmalıdır, adlandırma kuralları ise kaçınmak için oldukça faydalı olabilir.</p>
<p>Yöntemlerin içinden veri niteliklerine (veya diğer metotlara!) başvurmak için kısa yol yoktur.  Bu aslında metotların okunabilirliğini arttırıyor, çünkü bir metoda bakarken yerel değişkenleri ve örnek değişkenlerini karıştırma ihtimali bırakmamış oluyoruz.</p>
<p>Genellikle, bir metodun ilk bağımsız değişkenine <code class="docutils literal notranslate"><span class="pre">self</span></code> denir.  Bu bir kullanım geleneğinden başka bir şey değildir, yani <code class="docutils literal notranslate"><span class="pre">self</span></code> adının Python için kesinlikle özel bir anlamı yoktur.  Bununla birlikte, kurala uymadığınızda kodunuzun diğer Python programcıları tarafından daha az okunabilir olabileceğini ve yazılabilecek potansiyel bir <em>sınıf tarayıcısı</em> programının bu kurala dayanıyor olabileceğini unutmayın.</p>
<p>Sınıf niteliği olan herhangi bir fonksiyon nesnesi, bu sınıfın örnekleri için bir metot tanımlar.  Fonksiyon tanımının metinsel olarak sınıf tanımına dahil olması gerekli değildir: sınıftaki yerel bir değişkene fonksiyon nesnesi atamak da uygundur.  Mesela:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function defined outside the class</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">h</span></code> are all attributes of class <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> that refer to
function objects, and consequently they are all methods of instances of
<code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> — <code class="docutils literal notranslate"><span class="pre">h</span></code> being exactly equivalent to <code class="docutils literal notranslate"><span class="pre">g</span></code>.  Note that this practice
usually only serves to confuse the reader of a program.</p>
<p>Metotlar, <code class="docutils literal notranslate"><span class="pre">self</span></code> bağımsız değişkeninin metot niteliklerini kullanarak diğer metotları çağırabilir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bag</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addtwice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Metotlar, global adlara sıradan işlevler gibi başvuru yapabilir.  Bir metotla ilişkili genel kapsam, tanımını içeren modüldür.  (Bir sınıf hiçbir zaman genel kapsam olarak kullanılmaz.)  Global verileri bir metotta kullanmak için nadiren iyi bir nedenle karşılaşılsa da, genel kapsamın birçok meşru kullanımı vardır: bir kere, genel kapsamlıya içe aktarılan fonksiyon ve modüller, metotlar ve içinde tanımlanan fonksiyonlar ve sınıflar tarafından kullanılabilir.  Genellikle, metodu içeren sınıfın kendisi bu genel kapsamda tanımlanır ve sonraki bölümde bir yöntemin kendi sınıfına başvurmak istemesinin bazı iyi nedenlerini bulacağız.</p>
<p>Her değer bir nesnedir ve bu nedenle bir <em>sınıf</em> (<em>type</em> olarak da adlandırılır) bulundurur. <code class="docutils literal notranslate"><span class="pre">object.__class__</span></code> olarak depolanır.</p>
</section>
<section id="inheritance">
<span id="tut-inheritance"></span><h2><span class="section-number">9.5. </span>Kalıtım<a class="headerlink" href="#inheritance" title="Permalink to this heading">¶</a></h2>
<p>Tabii ki, bir dil özelliği kalıtımı desteklemeden “sınıf” adına layık olmaz.  Türetilmiş sınıf tanımının söz dizimi şöyle görünür:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">BaseClassName</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The name <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseClassName</span></code> must be defined in a scope containing the
derived class definition.  In place of a base class name, other arbitrary
expressions are also allowed.  This can be useful, for example, when the base
class is defined in another module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">modname</span><span class="o">.</span><span class="n">BaseClassName</span><span class="p">):</span>
</pre></div>
</div>
<p>Türetilmiş bir sınıf tanımının yürütülmesi, temel sınıfla aynı şekilde devam eder. Sınıf nesnesi inşa edildiğinde, temel sınıf hatırlanır.  Bu, nitelik başvurularını çözmek için kullanılır: istenen nitelik sınıfta bulunmazsa, arama temel sınıfa bakmaya devam eder.  Temel sınıfın kendisi başka bir sınıftan türetilmişse, bu kural özyinelemeli olarak uygulanır.</p>
<p>Türetilmiş sınıfların somutlaştırılmasında özel bir şey yoktur: <code class="docutils literal notranslate"><span class="pre">DerivedClassName()</span></code> sınıfın yeni bir örneğini oluşturur.  Metot başvuruları aşağıdaki gibi çözümlenir: ilgili sınıf niteliği aranır, gerekirse temel sınıflar zincirinin aşağısına inilir ve bu bir fonksiyon nesnesi veriyorsa metot başvurusu geçerlidir.</p>
<p>Türetilmiş sınıflar, temel sınıflarının metotlarını geçersiz kılabilir.  Metotlar aynı nesnenin diğer yöntemlerini çağırırken özel ayrıcalıkları olmadığından, aynı temel sınıfta tanımlanan başka bir metodu çağıran bir temel sınıfın metodu, onu geçersiz kılan türetilmiş bir sınıfın metodunu çağırabilir.  (C++ programcıları için: Python’daki tüm yöntemler etkili bir şekilde <code class="docutils literal notranslate"><span class="pre">sanal</span></code>.)</p>
<p>Türetilmiş bir sınıfta geçersiz kılma yöntemi aslında yalnızca aynı adlı temel sınıf yöntemini değiştirmek yerine genişletmek isteyebilir. Temel sınıf metodunu doğrudan çağırmanın basit bir yolu vardır: sadece <code class="docutils literal notranslate"><span class="pre">BaseClassName.methodname(self,</span> <span class="pre">arguments)</span></code> çağırın.  Bu bazen müşteriler için de yararlıdır.  (Bunun yalnızca temel sınıfa genel kapsamda <code class="docutils literal notranslate"><span class="pre">BaseClassName</span></code> olarak erişilebiliyorsa çalıştığını unutmayın.)</p>
<p>Python’un kalıtımla çalışan iki yerleşik fonksiyonu vardır:</p>
<ul class="simple">
<li><p>Bir örneğin türünü denetlemek için <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> kullanın: <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></code> yalnızca <code class="docutils literal notranslate"><span class="pre">obj.__class__</span></code> <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> veya <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> sınıfından türetilmiş bir sınıfsa <code class="docutils literal notranslate"><span class="pre">True</span></code> olacaktır.</p></li>
<li><p>Sınıf kalıtımını denetlemek için <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> kullanın: <code class="docutils literal notranslate"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></code> <code class="docutils literal notranslate"><span class="pre">True</span></code> ‘dur, çünkü <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> ‘in bir alt sınıfıdır.  Ancak, <code class="docutils literal notranslate"><span class="pre">issubclass(float,</span> <span class="pre">int)</span></code> <code class="docutils literal notranslate"><span class="pre">False</span></code> olduğundan <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> alt sınıfı değildir.</p></li>
</ul>
<section id="multiple-inheritance">
<span id="tut-multiple"></span><h3><span class="section-number">9.5.1. </span>Çoklu Kalıtım<a class="headerlink" href="#multiple-inheritance" title="Permalink to this heading">¶</a></h3>
<p>Python, çoklu kalıtım biçimini de destekler.  Birden çok temel sınıf içeren bir sınıf tanımı şöyle görünür:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span><span class="p">,</span> <span class="n">Base3</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>For most purposes, in the simplest cases, you can think of the search for
attributes inherited from a parent class as depth-first, left-to-right, not
searching twice in the same class where there is an overlap in the hierarchy.
Thus, if an attribute is not found in <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivedClassName</span></code>, it is searched
for in <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code>, then (recursively) in the base classes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code>,
and if it was not found there, it was searched for in <code class="xref py py-class docutils literal notranslate"><span class="pre">Base2</span></code>, and so on.</p>
<p>Aslında, durum bundan biraz daha karmaşıktır: yöntem çözümleme sırası, <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> için işbirliği çağrılarını desteklemek için dinamik olarak değişir.  Bu yaklaşım, diğer bazı çoklu kalıtım dillerinde sonraki çağrı yöntemi olarak bilinir ve tekli kalıtım dillerinde bulunan süper çağrıdan daha güçlüdür.</p>
<p>Çoklu kalıtımın tüm durumları bir veya daha fazla elmas ilişkisi gösterdiğinden (üst sınıflardan en az birine, en alttaki sınıftan birden çok yol üzerinden erişilebildiği ilişkiler) dinamik sıralama gereklidir.  Örneğin, tüm sınıflar <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> öğesini devralır, bu nedenle çoklu kalıtım durumu <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> ‘e ulaşmak için birden fazla yol sağlar. Temel sınıflara birden çok kez erişilmesini önlemek için, dinamik algoritma arama sırasını her sınıfta belirtilen soldan sağa sıralamayı koruyacak şekilde doğrular, her üst öğeyi yalnızca bir kez çağırır ve monotondur (yani bir sınıf, üst sınıfının öncelik sırasını etkilemeden alt sınıflandırılabilir). Birlikte ele alındığında, bu özellikler çoklu kalıtım ile güvenilir ve genişletilebilir sınıflar tasarlamayı mümkün kılar.  Daha fazla ayrıntı için bkz. <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>.</p>
</section>
</section>
<section id="private-variables">
<span id="tut-private"></span><h2><span class="section-number">9.6. </span>Özel Değişkenler<a class="headerlink" href="#private-variables" title="Permalink to this heading">¶</a></h2>
<p>Python’da bir nesnenin içinden erişilmesi dışında asla erişilemeyen “özel” örnek değişkenleri yoktur.  Ancak, çoğu Python kodu tarafından izlenen bir kural vardır: alt çizgi (örneğin <code class="docutils literal notranslate"><span class="pre">_spam</span></code>) ile öneklenmiş bir ad API’nin genel olmayan bir parçası olarak kabul edilmelidir (bir fonksiyon, metot veya veri üyesi olsun).  Bir uygulama detayıdır ve önceden haber verilmeksizin değiştirilebilir.</p>
<p id="index-1">Sınıf-özel üyeler için geçerli bir kullanım örneği olduğundan (yani alt sınıflar tarafından tanımlanan adlara sahip adların ad çakışmasını önlemek için), <em class="dfn">name mangling</em> adı verilen böyle bir mekanizma için sınırlı destek vardır.  <code class="docutils literal notranslate"><span class="pre">__spam</span></code> formunun herhangi bir tanımlayıcısı (en az iki satır altı, en fazla bir alt çizgi) metinsel olarak <code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code> ile değiştirilir;  Bu mangling, bir sınıfın tanımı içinde gerçekleştiği sürece tanımlayıcının söz dizimsel konumuna bakılmaksızın yapılır.</p>
<p>Ad mangling, alt sınıfların sınıf içi metot çağrılarını kesmeden metotları geçersiz kılmasına izin vermek için yararlıdır.  Mesela:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">__update</span> <span class="o">=</span> <span class="n">update</span>   <span class="c1"># private copy of original update() method</span>

<span class="k">class</span> <span class="nc">MappingSubclass</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># provides new signature for update()</span>
        <span class="c1"># but does not break __init__()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>Yukarıdaki örnek, <code class="docutils literal notranslate"><span class="pre">MappingSubclass</span></code> sırasıyla <code class="docutils literal notranslate"><span class="pre">Mapping</span></code> sınıfında <code class="docutils literal notranslate"><span class="pre">_Mapping__update</span></code> ve <code class="docutils literal notranslate"><span class="pre">mappingSubclass</span></code> sınıfında <code class="docutils literal notranslate"><span class="pre">_MappingSubclass__update</span></code> ile değiştirildiği için <code class="docutils literal notranslate"><span class="pre">__update</span></code> tanımlayıcısı tanıtsa bile çalışır.</p>
<p>Mangling kurallarının çoğunlukla kazaları önlemek için tasarlandığını unutmayın; özel olarak kabul edilen bir değişkene erişmek veya değiştirmek hala mümkündür.  Bu, hata ayıklayıcı gibi özel durumlarda bile yararlı olabilir.</p>
<p><code class="docutils literal notranslate"><span class="pre">exec()</span></code> veya <code class="docutils literal notranslate"><span class="pre">eval()</span></code> koduna geçirilen kodun çağırma sınıfının sınıf adını geçerli sınıf olarak görmediğine dikkat edin; bu, etkisi aynı şekilde birlikte bayt derlenmiş kodla sınırlı olan <code class="docutils literal notranslate"><span class="pre">global</span></code> deyiminin etkisine benzer.  Aynı kısıtlama <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> ve <code class="docutils literal notranslate"><span class="pre">delattr()</span></code> ve doğrudan <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> atıfta bulunurken de geçerlidir.</p>
</section>
<section id="odds-and-ends">
<span id="tut-odds"></span><h2><span class="section-number">9.7. </span>Oranlar ve Bitişler<a class="headerlink" href="#odds-and-ends" title="Permalink to this heading">¶</a></h2>
<p>Bazen, birkaç adlandırılmış veri öğesini bir araya getirerek Pascal <em>record</em> ‘u veya C <em>struct</em> ‘ına benzer bir veri türüne sahip olmak yararlıdır. Deyimsel yaklaşım, bu amaç için <a class="reference internal" href="../library/dataclasses.html#module-dataclasses" title="dataclasses: Generate special methods on user-defined classes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code></a> kullanmaktır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">dept</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">salary</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;john&#39;</span><span class="p">,</span> <span class="s1">&#39;computer lab&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">john</span><span class="o">.</span><span class="n">dept</span>
<span class="go">&#39;computer lab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">john</span><span class="o">.</span><span class="n">salary</span>
<span class="go">1000</span>
</pre></div>
</div>
<p>A piece of Python code that expects a particular abstract data type can often be
passed a class that emulates the methods of that data type instead.  For
instance, if you have a function that formats some data from a file object, you
can define a class with methods <a class="reference internal" href="../library/io.html#io.TextIOBase.read" title="io.TextIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> and
<a class="reference internal" href="../library/io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> that get the
data from a string buffer instead, and pass it as an argument.</p>
<p>Instance method objects have attributes, too: <code class="docutils literal notranslate"><span class="pre">m.__self__</span></code> is the instance
object with the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">m()</span></code>, and <code class="docutils literal notranslate"><span class="pre">m.__func__</span></code> is the function object
corresponding to the method.</p>
</section>
<section id="iterators">
<span id="tut-iterators"></span><h2><span class="section-number">9.8. </span>Yineleyiciler<a class="headerlink" href="#iterators" title="Permalink to this heading">¶</a></h2>
<p>Şimdiye kadar büyük olasılıkla çoğu kapsayıcı nesnenin bir <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> deyimi kullanılarak döngüye alınabileceğini fark etmişsinizdir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;123&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Bu erişim tarzı açık, özlü ve kullanışlıdır.  Yineleyicilerin kullanımı Python’u istila eder ve birleştirir.  Perde arkasında <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> deyimi kapsayıcı nesne üzerinde <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> öğesini çağırır.  Fonksiyon, kapsayıcıdaki öğelere teker teker erişen <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> metodunu tanımlayan bir yineleyici nesnesi döndürür.  Başka öğe olmadığında, <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> döngüsünün sonlandırılacağını bildiren bir <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> hatası oluşturur.  <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> yerleşik fonksiyonunu kullanarak <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> yöntemini çağırabilirsiniz; Bu örnek, her şeyin nasıl çalıştığını gösterir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;str_iterator object at 0x10c90e650&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>Having seen the mechanics behind the iterator protocol, it is easy to add
iterator behavior to your classes.  Define an <a class="reference internal" href="../library/stdtypes.html#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method which
returns an object with a <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method.  If the class
defines <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code>, then <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> can just return <code class="docutils literal notranslate"><span class="pre">self</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reverse</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rev</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">iter</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
<span class="go">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</section>
<section id="generators">
<span id="tut-generators"></span><h2><span class="section-number">9.9. </span>Üreteçler<a class="headerlink" href="#generators" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">Üreteçler</span></a> yineleyiciler oluşturmak için basit ve güçlü bir araçtır.  Normal fonksiyonlar gibi yazılırlar, ancak veri döndürmek istediklerinde <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> deyimini kullanırlar.  Üzerinde her <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> çağrıldığı zaman, üreteç kaldığı yerden devam eder (tüm veri değerlerini ve hangi deyimin en son yürütüldüğını hatırlar).  Bu örnek, üreteçlerin oluşturulmasının ne kadar da kolay olabileceğini gösterir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>Anything that can be done with generators can also be done with class-based
iterators as described in the previous section.  What makes generators so
compact is that the <a class="reference internal" href="../library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> and <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> methods
are created automatically.</p>
<p>Başka bir önemli özellik, yerel değişkenlerin ve yürütme durumunun çağrılar arasında otomatik olarak kaydedilmesidir.  Bu, fonksiyonun yazılmasını kolaylaştırdı ve <code class="docutils literal notranslate"><span class="pre">self.index</span></code> ve <code class="docutils literal notranslate"><span class="pre">self.data</span></code> gibi değişkenleri kullanmaya kıyasla çok daha net hale getirdi.</p>
<p>Otomatik metot oluşturma ve kaydetme programı durumuna ek olarak, üreteçler sonlandırıldığında otomatik olarak <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ‘ı yükseltirler. Birlikte, bu özellikler normal bir işlev yazmaktan daha fazla çaba harcamadan yinelemeler oluşturmayı kolaylaştırır.</p>
</section>
<section id="generator-expressions">
<span id="tut-genexps"></span><h2><span class="section-number">9.10. </span>Üreteç İfadeleri<a class="headerlink" href="#generator-expressions" title="Permalink to this heading">¶</a></h2>
<p>Bazı basit üreteçler, listelere benzer bir söz dizimi kullanılarak ve köşeli ayraçlar yerine parantezlerle kısaca kodlanabilir. Bu ifadeler, üreteçlerin kapsayıcı bir fonksiyon tarafından hemen kullanıldığı durumlar için tasarlanmıştır.  Üreteç ifadeleri tam üreteç tanımlarından daha kompakt ancak daha az çok yönlüdür ve aynı özellikle liste anlamalarından daha bellek dostu olma eğilimindedir.</p>
<p>Örnekler:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c1"># sum of squares</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c1"># dot product</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">valedictorian</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">student</span><span class="o">.</span><span class="n">gpa</span><span class="p">,</span> <span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">graduates</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">Dipnotlar</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Bir şey hariç.  Modül nesneleri,  <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>  denen sadece okunabilir bir özelliğe sahiptir, bu da modülün ad alanını uygulamak için bir sözlük döndürür: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> ismi bir özellik olsa da global bir isim değildir. Kuşkusuz, bu durum ad alanlarının soyutlanış özelliklerine aykırı, dolayısıyla sadece programın durması sonrası çalışan hata ayıklayıcılar gibilerinin kullanımına kısıtlanmalı.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">İçindekiler</a></h3>
    <ul>
<li><a class="reference internal" href="#">9. Sınıflar</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. İsim ve Nesneler Hakkında Birkaç Şey</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Python Etki Alanları ve Ad Alanları</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. Kapsamlar ve Ad Alanları Örneği</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. Sınıflara İlk Bakış</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Sınıf Tanımlama Söz Dizimi</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Sınıf Nesneleri</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. Örnek Nesneleri</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Metot Nesneleri</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Sınıf ve Örnek Değişkenleri</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. Rastgele Açıklamalar</a></li>
<li><a class="reference internal" href="#inheritance">9.5. Kalıtım</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. Çoklu Kalıtım</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. Özel Değişkenler</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. Oranlar ve Bitişler</a></li>
<li><a class="reference internal" href="#iterators">9.8. Yineleyiciler</a></li>
<li><a class="reference internal" href="#generators">9.9. Üreteçler</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. Üreteç İfadeleri</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Önceki konu</h4>
    <p class="topless"><a href="errors.html"
                          title="önceki bölüm"><span class="section-number">8. </span>Hatalar ve Özel Durumlar</a></p>
  </div>
  <div>
    <h4>Sonraki konu</h4>
    <p class="topless"><a href="stdlib.html"
                          title="sonraki bölüm"><span class="section-number">10. </span>Standart Kütüphanenin Özeti</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Bu Sayfa</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Hata Bildir</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/tutorial/classes.rst"
            rel="nofollow">Kaynağı Göster
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Yan çubuğu daralt">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Genel Endeks"
             >dizin</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Modül Dizini"
             >modülleri</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Standart Kütüphanenin Özeti"
             >sonraki</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. Hatalar ve Özel Durumlar"
             >önceki</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python Öğreticisi</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Sınıflar</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="search" name="q" id="search-box" />
          <input type="submit" value="Git" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Telif Hakkı</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Son güncelleme: Eki 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.1.
    </div>

  </body>
</html>